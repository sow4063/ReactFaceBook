// Generated by CoffeeScript 1.6.1
var EXTENSIONS, File, IMPORT_RE, SourceMap, fs, path, utils, _ref,
  _this = this;

fs = require('fs');

path = require('path');

utils = require('./utils');

_ref = require('./importer'), IMPORT_RE = _ref.IMPORT_RE, EXTENSIONS = _ref.extensions;

SourceMap = require('./sourcemap');

File = (function() {

  function File(_package, filename) {
    var _this = this;
    this["package"] = _package;
    this.filename = filename;
    this.load = function(callback) {
      return File.prototype.load.apply(_this, arguments);
    };
    this.path = null;
    this.ext = null;
    this.mtime = null;
    this.dependencies = [];
    this.source = '';
    this.compiled = '';
    this.sourceMap = null;
    this.cache = '';
  }

  File.prototype.resolve = function(callback) {
    var changed, check, done, ext, fullname,
      _this = this;
    fullname = path.resolve(this.filename);
    changed = false;
    check = function(ext, fn) {
      return utils.stat(_this["package"].sync, fullname + ext, function(err, stat) {
        if (err || stat.isDirectory()) {
          return fn(false);
        }
        return utils.realpath(_this["package"].sync, fullname + ext, function(err, realpath) {
          if (err) {
            return fn(false);
          }
          if (+stat.mtime !== _this.mtime || realpath !== _this.path) {
            _this.mtime = +stat.mtime;
            _this.path = realpath;
            changed = true;
          }
          _this.ext = ext;
          return fn(true);
        });
      });
    };
    done = function(found) {
      if (!found) {
        _this.path = _this.mtime = _this.ext = null;
        return callback(new Error('"' + _this.filename + '" could not be found.'));
      }
      return callback(null, changed);
    };
    ext = path.extname(fullname);
    if (ext in EXTENSIONS) {
      fullname = fullname.slice(0, -ext.length);
      return check(ext, done);
    }
    return utils.some(this["package"].sync, Object.keys(EXTENSIONS), check, done);
  };

  File.prototype.parse = function() {
    var filename, result;
    this.dependencies.length = 0;
    IMPORT_RE.lastIndex = 0;
    while (result = IMPORT_RE.exec(this.compiled)) {
      filename = result[1].slice(1, -1);
      if (result[1][0] === '<') {
        filename = path.join(path.resolve(this["package"].frameworkPath), filename);
      }
      if (filename[0] !== '/') {
        filename = path.join(path.dirname(this.path), filename);
      }
      this.dependencies.push({
        offset: result.index,
        length: result[0].length,
        file: this["package"].load(filename)
      });
    }
  };

  File.prototype.load = function(callback) {
    var _this = this;
    return this.resolve(function(err, changed) {
      if (err || !changed) {
        return callback(err, changed);
      }
      return utils.readFile(_this["package"].sync, _this.path, 'utf8', function(err, source) {
        var compiled;
        _this.source = source;
        if (err) {
          return callback(err);
        }
        try {
          compiled = EXTENSIONS[_this.ext](_this.source, !!_this["package"].sourceMap);
        } catch (err) {
          _this.mtime = null;
          throw err;
          return callback(new Error("" + err + " in " + _this.path));
        }
        if (typeof compiled === 'string') {
          _this.compiled = compiled;
          _this.sourceMap = null;
        } else {
          _this.compiled = compiled.code;
          _this.sourceMap = compiled.map;
        }
        _this.parse();
        return callback(null, changed);
      });
    });
  };

  File.prototype.compile = function(callback) {
    var _this = this;
    return this.load(function(err, changed) {
      var compileDependency;
      if (err) {
        return callback(err);
      }
      if (_this["package"].imported[_this.path]) {
        return callback(null, null);
      }
      _this["package"].imported[_this.path] = true;
      compileDependency = function(dep, fn) {
        return dep.file.compile(fn);
      };
      return utils.mapSeries(_this["package"].sync, _this.dependencies, compileDependency, function(err, deps) {
        var dep, i, _i, _len, _ref1;
        if (err) {
          return callback(err);
        }
        changed || (changed = deps.some(function(dep) {
          return dep;
        }));
        if (_this.cache && !changed) {
          return callback(null, false);
        }
        _this.cache = new SourceMap({
          source: _this.source,
          compiled: _this.compiled,
          makeSourceMap: _this["package"].sourceMap,
          inSourceMap: _this.sourceMap,
          filename: path.relative(process.cwd(), _this.path)
        });
        _ref1 = _this.dependencies;
        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
          dep = _ref1[i];
          _this.cache.addSegment(dep.offset);
          _this.cache.compiledOffset += dep.length + 1;
          if (deps[i] != null) {
            _this.cache.addSource(dep.file.cache);
          }
        }
        _this.cache.addSegment(_this.compiled.length);
        return callback(null, true);
      });
    });
  };

  return File;

})();

module.exports = File;
